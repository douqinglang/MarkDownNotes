# java设计模式
## 设计模式划分
设计模式有两种分类方法
1. 根据目的划分
- 创建型模式
描述对象"怎样创建对象", 主要特点是"将对象的创建和使用分离". 总共有单例, 原型, 工厂方法, 抽象工厂, 建造者等5中设计模式
- 结构型模式
描述如何将类或对象按照某种布局组成更大的结构. 共有: 代理, 适配器, 桥接, 装饰 ,外观, 享元, 组合等7种结构型模式
- 行为型模式
描述类或对象之间怎样相互协作共同完成单个对象无法完成的任务, 以及怎么分配职责: 共有模板方法, 策略, 命令, 责任链, 状态, 观察, 中介者, 迭代器, 访问者, 备忘录, 解释器等11种行为模式
2. 根据作用范围划分
- 类模式
处理类与子类之间的关系, 关系通过继承来建立, 是静态的, 在编译时刻就确定了. 主要有: 工厂方法, 类适配器, 模板方法, 解释器
- 对象模式
处理对象之间的关系, 关系可以通过组合或聚合实现, 在运行时是可以变化的, 具有动态性. 除以上四种都是对象模式
|范围\目的|创建型模式|结构型模式|行为型模式|
|--	|--	|--	|--	|
|类模式|	工厂方法|类适配器|模板方法, 解释器|
|对象模式|单例, 原型, 抽象工厂, 建造者|代理, 对象适配器, 桥接, 装饰, 外观, 享元, 组合|策略, 命令, 责任链, 状态, 观察者, 中介者, 迭代器, 访问者, 备忘录|

## 各种设计模式功能说明
1. 单例(singleton)模式: 某个类只能生成一个实例, 提供一个全局访问方法供外部获取实例, 拓展是有限多例模式
2. 原型(prototype)模式: 将一个类对象作为原型, 通过对其复制而克隆出多个和原型类似的新实例
3. 工厂方法(factory method)模式: 定义一个用于创建产品的结构, 由子类决定生产什么产品
4. 抽象工厂(abstract method)模式: 提供一个一个创建产品族的接口, 其每一个子类可以生产一系列产品
5. 建造者(builder)模式: 将一个复杂的对象分解成多个相对简单的部分, 然后根据不同需要分别创建他们, 最后构建成该复杂对象
6. 代理(proxy)模式: 为某一对象提供一种代理以控制该对象的访问. 即客户端通过代理间接访问该对象, 从而限制, 增强或修改该对象的一些特性
7. 适配器(adapter)模式: 将一个接口转换成客户需要的另一个接口, 使得原本因为接口不兼容而不同一同工作的那些类能一起工作
8. 桥接(bridge)模式: 将抽象和实现分离, 使它们可以独立变化. 用组合关系代替继承关系实现, 降低抽象和实现的耦合度
9. 装饰(decorator)模式: 动态的给对象增加一些职责, 即增加其额外功能
10. 外观(facade)模式: 为多个复杂的子系统提供一个一致接口, 使这些子系统更加容易被访问
11. 享元(flyweight)模式: 运用共享技术有效地支持大量细粒度对象的复用
12. 组合(composite)模式: 将对象组合成树状层次结构, 使用户对单个对象和组合对象具有一致的访问性
13. 模板方法(template method)模式: 定义一个操作中的算法骨架, 将算法的一些步骤延迟到子类中, 使得子类可以不改变该算法的结构的情况下重定义该算法的某些特定步骤
14. 策略(strategy)模式: 定义了一系列算法, 并将每个算法封装起来, 使它们可以相互替换, 且算法的改变不会影响使用算法的客户
15. 命令(command)模式: 将一个请求封装为一个对象, 使得发出请求的责任和执行请求的责任分开
16. 责任链(chain of responsibility)模式: 把请求从链中的一个对象传递到下一个对象, 知道请求被响应为止, 通过这种方法去除对象间的耦合
17. 状态(state)模式: 允许一个对象在其内部状态发生改变时改变其行为能力
18. 观察者(observer)模式: 多个对象建存在一对多的关系, 当一个对象发生改变时, 把这种改变通知给其他对象, 从而影响其他对象的行为
19. 中介者(mediator)模式: 定义一个中介对象来简化原有对象之间的交互关系, 降低系统对象间的耦合度
20. 迭代器(iterator)模式: 提供一种方法顺序访问对象中的一系列数据, 而不暴露聚合对象的内部
21. 访问者(visitor)模式: 在不改变集合元素的前提下, 为一个集合中的每一个元素提供多种访问方式, 即每个元素有多个访问者对象访问
22. 备忘录(memento)模式: 在不破坏封装性的前提下, 获取并保存对象的内部状态, 以便恢复
23. 解释器(interpreter)模式: 提供如何定义语言的文法, 以及对语言句子的解释方法, 即解释器。

## 各种设计模式详解和示例
### 1. 单例模式
一个类只有一个实例, 且该类能自行创建这个实例的一种模式. 例如: Windows 中只能打开一个任务管理器, 避免因打开多个任务管理器窗口而造成内存资源的浪费, 或出现各个窗口显示内容的不一致等错误
特点:
- 单例类只有一个实例对象
- 该单例对象必须由单例类自行创建
- 单例类对外提供一个访问该单例的全局访问点

![UML 单例模式的结构图](http://c.biancheng.net/uploads/allimg/181113/3-1Q1131K441K2.gif)

#### (1) 懒汉式单例
模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例
编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点
```java
public class LazySingleton
{
    private static volatile LazySingleton instance=null;    //保证 instance 在所有线程中同步
    private LazySingleton(){}    //private 避免类在外部被实例化
    public static synchronized LazySingleton getInstance()
    {
        //getInstance 方法前加同步
        if(instance==null)
        {
            instance=new LazySingleton();
        }
        return instance;
    }
}
```
#### (2) 饿汉式单例
特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了
饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题
```java
public class HungrySingleton
{
    private static final HungrySingleton instance=new HungrySingleton();
    private HungrySingleton(){}
    public static HungrySingleton getInstance()
    {
        return instance;
    }
}
```
### 2.
### 3.
### 4.
### 5.
### 6.
### 7.
### 8.
### 9.
### 10.
### 11.
### 12.
### 13.
### 14.
### 15.
### 16.
### 17.
### 18.
### 19.
### 20.
### 21.
### 22.
### 23.